We consider the problem of {\sf Outsourced Computation} where a computationally  ``weak'' client hires a more  ``powerful'' server to store data and perform computations on its behalf. This paper is concerned with the problem of designing outsourced computation schemes that incentivize the server to perform correctly the tasks assigned by the client. 

The rise of the {\em cloud computing} paradigm where business do not maintain their own IT infrastructure, but rather hire  ``providers'' to run it, has brought this problem to the forefront of the research community. The goal is to find solutions that are efficient and feasible in practice for problems such as: How do we check the integrity of data that is stored remotely? How do we check computations performed on this remotely stored data? How can a client do this in the most efficient way possible? Or even more generally, how do we incentivize parties to perform correctly in such scenarios?



\subsection{Repeated Executions with a Budget}
%\medskip
%\noindent
%{\sc Compositions of Rational Proofs.}
In \cite{cg15} 
%the authors 
we present a critique of the rational proof model in the case of ``repeated executions with a budget". This model arises in the context of ``volunteer computations" (\cite{seti,folding}) where many computational tasks are outsourced and provers compete in solving as many as possible to obtain rewards. In this scenario assume that a prover has a certain budget $B$ of ``computational effort": how can one  guarantee that the rational strategy is to provide the correct answer in {\em all} the proof he provides? The notion of rational proof guarantees that if the prover engages in a single rational proof then it is in his best interest to provide the correct output. But in \cite{cg15} 
%the authors
we show that in the presence of many computations, it might be more profitable for the prover to use his budget $B$ to provide many incorrect answers than to provide a single correct answer. That's because incorrect (e.g. random) answers are ``cheaper" to compute than the correct one and with the same budget $B$ the prover can provide many of them while the entire budget might be necessary to solve a single problem correctly. If the difference in reward between correct and incorrect answers is not high enough then many incorrect answers may be more profitable and a rational prover will choose that strategy, and indeed this is the case for many of the protocols in \cite{am,am1,ratargs,ratsumchecks}. 

In \cite{cg15} we put forward a stronger notion of {\em sequentially composable rational proofs} which avoids the above problem and guarantees that the rational strategy is always the one to provide correct answers. We also presented sequentially composable rational proofs, but only for some ad-hoc cases, and were not able to generalize them to well-defined complexity classes. 

%for a subset of bounded-depth circuit computations. 




